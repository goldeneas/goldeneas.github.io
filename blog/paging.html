<h1> Paging della memoria </h1>
<p>
La memoria centrale di un calcolatore è sostanzialmente un'enorme insieme di 0 ed 1 che da soli non hanno alcun senso. Attraverso la codifica di questi numeri ci è possibile conservare dell'informazione che può essere usata dai processi del nostro computer. <br />
Tuttavia, ci siamo mai chiesti come possa il sistema operativo, ed in particolare il kernel, tener conto di quale zona della memoria é assegnata a quale processo attualmente in corso? Se un processo deve essere creato, quale zona della memoria deve essere assegnata a quel processo? È una zona libera o ci sono altri dati che non possiamo eliminare? E se un altro processo deve essere eliminato? Quale zona della memoria può essere "riciclata" e riassegnata ad un nuovo processo? <br />
É dunque evidente che il sistema operativo compie un enorme lavoro per la gestione della memoria; per cercare di semplificare questo concetto ho pensato ad una metafora interessante.
</p>

<h2> E se la memoria centrale fosse un quaderno?  </h2>
<p>
Immaginiamo che all'accensione del nostro calcolatore la memoria sia inizializzata a 0 (cioé tutti gli indirizzi di memoria contengono degli 0) e che il nostro ruolo sia quello del kernel del sistema operativo. Come possiamo permettere l'allocazione di memoria da parte di un processo che vorrebbe essere eseguito? <br />
La soluzione più banale sarebbe quella di prendere un indirizzo della memoria che sappiamo essere vuoto (come lo sappiamo?) e lo diamo al processo. Il processo può occupare n bytes di memoria a partire da quell'indirizzo. Un programma molto stupido potrebbe ad esempio allocare 6 bytes di memoria all'indirizzo 0xf400 e poi terminare l'esecuzione. <br />
Tralasciando l'inutilità disarmante del processo appena menzionato, sorge fin da subito un grande problema: come facciamo a ""pulire"" quella parte di memoria e a riutilizzarla per un altro processo? Dovremmo tener conto in qualche modo di quale processo abbia usato quella memoria, dell'indirizzo che gli abbiamo assegnato e di quanti byte quel processo abbia effettivamente utilizzato. <br />
Invece di consegnare al processo un singolo indirizzo nel caos della memoria centrale, possiamo immaginare che la RAM sia in realtá un grande quaderno suddiviso in pagine. Ogni pagina può contenere un massimo numero di n bytes, ed ogni pagina è assegnata ad un processo. Quando un processo deve allocare memoria, possiamo assegnare un nuovo indirizzo di quelli presenti nella pagina del nostro quaderno, e quando il processo fermina, semplicemente azzeriamo la pagina dall'inizio alla fine. </br >
Questa è l'idea di base dietro il paging, che rende più organizzato il processo di gestione della memoria. <br />
E se gli indirizzi/la memoria della pagina non bastano per il nostro processo? Ci basterà allocare un'ulteriore pagina, e poi ripetere i passaggi precedenti per assegnare la memoria ricordandoci che alla terminazione del processo vogliamo ripulire tutte le pagine ad esso assegnate (che è comunque più facile che ripulire ogni indirizzo, dove per pulire e ripulire si intende tener conto che quegli indirizzi che una volta erano in uso, ora non lo sono più e possono essere nuovamente assegnati ad un processo).
</p>